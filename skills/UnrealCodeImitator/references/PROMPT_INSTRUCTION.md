# LLM 提示词指令 - Unreal 代码学习 Skill

## 编译控制规则

### 默认行为（不涉及编译）

当你向 LLM 描述需求时，**默认情况下 LLM 不会执行编译**。

#### 例如：

```
我想学习 Unreal 的反射系统，参考官方源码实现一个自定义属性编辑器。
请生成框架代码。
```

**LLM 的行为：**
- ✅ 搜索网络获取教程和最佳实践
- ✅ 定位源码相关文件
- ✅ 分析反射系统的实现
- ✅ **生成代码框架**
- ❌ **不执行编译**
- ❌ **不运行脚本**

### 触发编译的关键词

当你明确要求编译时，只需在提示词中使用以下关键词之一：

#### 关键词列表

| 关键词 | 含义 | 优先级 |
|--------|------|--------|
| **编译** | 执行编译（默认Development） | ⭐⭐⭐ 最强 |
| **编译G** | 使用 DebugGame Editor 模式编译 | ⭐⭐⭐ 最强 |
| **编译V** | 使用 Development Editor 模式编译 | ⭐⭐⭐ 最强 |
| **编译S** | 使用 Shipping Editor 模式编译 | ⭐⭐⭐ 最强 |
| **compile** | 执行编译（英文） | ⭐⭐⭐ 最强 |
| **build** | 构建/编译 | ⭐⭐⭐ 最强 |
| **执行编译** | 明确执行编译 | ⭐⭐⭐ 最强 |
| **运行编译脚本** | 运行 compile.bat（唯一编译入口） | ⭐⭐⭐ 最强 |
| **测试编译** | 测试编译是否成功 | ⭐⭐⭐ 最强 |
| **生成并编译** | 同时生成代码和编译 | ⭐⭐⭐ 最强 |
| **迭代修复** | 循环编译和修复 | ⭐⭐⭐ 最强 |

#### 编译模式说明

| 模式关键词 | 编译配置 | 说明 | 适用场景 |
|----------|---------|------|---------|
| **编译G** | DebugGame Editor | 调试模式 - 包含调试符号，支持断点调试 | 需要深度调试插件代码 |
| **编译V** | Development Editor | 开发模式 - 默认编译模式，平衡性能和调试 | 日常开发和测试 |
| **编译S** | Shipping Editor | 发布模式 - 最大性能优化，移除调试代码 | 性能测试和正式发布 |

#### 不触发编译的词汇

以下词汇不会触发编译：

| 词汇 | 原因 |
|------|------|
| "生成代码" | 仅生成，不编译 |
| "给我代码" | 仅提供代码 |
| "参考源码" | 仅参考分析 |
| "学习" | 仅学习不动作 |
| "分析" | 仅分析不动作 |
| "解释" | 仅解释不动作 |

---

## 提示词示例

### 示例 1：生成代码（不编译）

```
我想创建一个自定义的 Actor Component，能够自动同步数据到客户端。
请参考 Unreal 源码中的 AActor 和 UActorComponent 的实现，
生成框架代码。
```

**LLM 行为：**
- 搜索相关教程
- 查找源码位置
- 生成代码
- ❌ 不编译

---

### 示例 2：生成并编译（触发编译）

```
我想创建一个自定义的 Actor Component，能够自动同步数据到客户端。
请参考 Unreal 源码中的 AActor 和 UActorComponent 的实现，
生成框架代码，然后编译。
```

**LLM 行为：**
- 搜索相关教程
- 查找源码位置
- 生成代码
- ✅ **执行编译（使用默认 Development 模式）**
- 如果有错误，显示错误日志

---

### 示例 2-G：使用 DebugGame 模式编译

```
我想创建一个自定义的 Actor Component，能够自动同步数据到客户端。
请参考 Unreal 源码中的 AActor 和 UActorComponent 的实现，
生成框架代码，然后编译G。
```

**LLM 行为：**
- 搜索相关教程
- 查找源码位置
- 生成代码
- ✅ **执行编译（使用 DebugGame Editor 模式 - 引擎优化，插件代码可调试）**
- 如果有错误，显示错误日志

---

### 示例 2-V：使用 Development 模式编译

```
我想创建一个自定义的 Actor Component，能够自动同步数据到客户端。
请参考 Unreal 源码中的 AActor 和 UActorComponent 的实现，
生成框架代码，然后编译V。
```

**LLM 行为：**
- 搜索相关教程
- 查找源码位置
- 生成代码
- ✅ **执行编译（使用 Development Editor 模式 - 引擎和插件都优化，等同于默认的\"编译\"）**
- 如果有错误，显示错误日志

---

### 示例 3：修复编译错误（触发编译）

```
我的代码编译出现了以下错误：

[粘贴错误日志]

请帮我分析和修复，然后重新编译。
```

**LLM 行为：**
- 分析错误原因
- 提出修复方案
- 生成修复代码
- ✅ **执行编译验证**
- 给出编译结果

---

### 示例 4：迭代开发（触发编译）

```
我想实现一个事件系统插件。请：
1. 学习 Unreal 的委托和事件系统
2. 生成插件框架
3. 编译并验证

如果有错误，自动修复并重新编译，直到成功。
```

**LLM 行为：**
- ✅ 学习和生成代码
- ✅ **执行编译**
- ✅ 如果有错误，自动分析和修复
- ✅ **循环编译直到成功**

---

## 编译时的详细流程

当你要求编译时，LLM 会执行以下步骤：

### 第 1 步：获取配置
```
读取 config.json：
- Unreal 引擎路径
- 搜索模块
- 其他编译选项
```

### 第 2 步：运行编译脚本
```
执行 compile.bat [BuildConfiguration]
编译脚本会：
- 从 Skill 根目录下的 config.json 读取 unrealEnginePath
- 正确解析包含 Windows 盘符的路径（如 `H:/Program Files/Epic Games/UE_5.4`）
- 验证引擎和项目路径
- 作为本 Skill 的唯一编译入口，统一封装所有 UE 编译命令
- 支持通过参数指定编译配置：DebugGame, Development (默认)
- 不再调用 `compile.ps1`（旧版脚本，已废弃）
- 全自动执行，无需用户交互（适合 Agent 调用）
- 执行编译命令并收集日志
```

**编译模式自动识别：**
- 当用户说"编译G"时 → 使用 `compile.bat DebugGame` → 编译为 DebugGame Editor
- 当用户说"编译V"或"编译"时 → 使用 `compile.bat Development` → 编译为 Development Editor

### 第 3 步：分析结果
```
编译成功？
  ├─ YES → 完成 ✅
  └─ NO  → 收集错误日志
```

### 第 4 步：如果有错误
```
LLM 会：
1. 显示错误摘要
2. 分析错误原因
3. 如果你要求"自动修复"，则生成修复代码并重新编译
4. 如果你只是查看，则等待你的指示
```

---

## 完整的提示词模板

### 模板 1：学习+生成（不编译）

```
我想学习 Unreal 中的 [功能名称]。

请：
1. 搜索相关教程和官方文档
2. 在源码中找到相关实现
3. 分析关键代码逻辑
4. 生成 [我要创建的内容] 的框架代码

参考 Unreal 源码中的最佳实践。
```

---

### 模板 2：学习+生成+编译（触发编译）

```
我想学习 Unreal 中的 [功能名称]，并创建一个自己的实现。

请：
1. 搜索相关教程和官方文档
2. 在源码中找到相关实现
3. 分析关键代码逻辑
4. 生成 [我要创建的内容] 的框架代码
5. 编译代码并报告结果

参考 Unreal 源码中的最佳实践。
```

---

### 模板 3：修复错误+编译（触发编译）

```
我的代码编译失败，以下是错误日志：

[粘贴错误日志内容]

请：
1. 分析错误原因
2. 提出修复方案
3. 生成修复后的代码
4. 编译验证
5. 如果仍有错误，自动迭代修复直到成功
```

---

### 模板 4：迭代开发（触发编译）

```
我想创建一个 [功能描述] 的插件。

过程：
1. 学习相关 Unreal 源码
2. 生成插件框架和实现代码
3. 编译并验证
4. 如果有编译错误，自动修复并重新编译，直到成功
5. 给出最终的可编译的代码

参考 [特定的源码模块] 的实现方式。
```

---

## 关键提示

### ✅ 如何明确要求编译

使用以下任何一个短语：

- "编译代码"
- "然后编译"
- "compile it"
- "build the code"
- "运行 compile.bat"（通过唯一编译入口执行）
- "使用 UnrealCodeImitator 编译"（等价于运行 compile.bat）
- "使用 UnrealCodeImitator 来编译"（等价于运行 compile.bat）
- "执行编译"
- "编译并验证"
- "编译并测试"
- "生成并编译"
- "迭代修复直到编译成功"

### ❌ 不会触发编译的表述

- "生成代码框架"
- "给我一个实现"
- "我想学习..."
- "参考源码"
- "分析一下"
- "解释这个功能"

### 🔄 编译后的行为

如果编译失败，LLM 会：

1. **显示错误日志**
   ```
   编译失败！
   错误数: 3
   
   [详细错误]
   ```

2. **等待你的指示**
   - 你可以继续提问
   - 你可以要求"修复这些错误"
   - 你可以要求"自动迭代修复"

3. **自动迭代（如果你要求）**
   ```
   如果你说："帮我修复这些错误，编译直到成功"
   
   LLM 会：
   ✅ 分析每个错误
   ✅ 生成修复代码
   ✅ 重新编译
   ✅ 如果仍有错误，重复修复
   ✅ 直到编译成功
   ```

---

## 编译脚本的输出

当编译成功时：
```
════════════════════════════════════════
编译成功！✅
════════════════════════════════════════

编译时长: 125.34 秒
错误数: 0
警告数: 0
```

当编译失败时：
```
════════════════════════════════════════
编译失败！❌
════════════════════════════════════════

发现 3 个编译错误

错误摘要:
[错误内容]
```

---

## 工作流建议

### 推荐的工作流

```
第 1 天：学习 + 生成代码（不编译）
  ↓
第 2 天：编译代码，修复错误
  ↓
第 3 天：功能测试和优化
```

### 快速迭代工作流

```
生成代码 + 编译 + 修复
  ↓ (自动迭代直到成功)
编译成功
  ↓
集成到项目
```

---

## 快速参考

### 触发编译的最短表述

```
生成并编译        # 使用默认 Development 模式
生成并编译G       # 使用 DebugGame 模式
生成并编译V       # 使用 Development 模式
生成并编译S       # 使用 Shipping 模式
```

### 要求自动修复

```
修复编译错误，重新编译直到成功
```

### 只生成代码

```
只给我代码，不要编译
```

### 仅学习不编译

```
我想了解这个功能，参考源码给我解释
```

---

## 总结

| 你的提示词 | 编译? | 编译模式 | 修复? | 自动迭代? |
|----------|-------|---------|-------|----------|
| "生成代码" | ❌ | - | - | - |
| "生成并编译" | ✅ | Development | - | - |
| "生成并编译G" | ✅ | DebugGame | - | - |
| "生成并编译V" | ✅ | Development | - | - |
| "生成并编译S" | ✅ | Shipping | - | - |
| "编译失败，帮我修" | ✅ | Development | ✅ | ❌ |
| "编译G失败，帮我修" | ✅ | DebugGame | ✅ | ❌ |
| "编译失败，自动迭代修复" | ✅ | Development | ✅ | ✅ |
| "学习+生成+编译" | ✅ | Development | - | - |
| "完整开发流程" | ✅ | Development | ✅ | ✅ |

---

**记住：** 
- 🔴 **默认不编译**
- 🟢 **只在你要求时编译**
- 🔵 **使用明确的关键词**
- 🎯 **编译G = DebugGame, 编译V = Development, 编译S = Shipping**

这样可以确保你对编译过程有完全的控制！

---

**最后更新：** 2025-11-28
