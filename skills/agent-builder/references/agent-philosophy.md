# Agent 的哲学

> **模型已经知道如何成为 agent。你的工作是不要妨碍它。**

## 根本洞察

剥离每一个框架、每一个库、每一个架构模式。剩下什么？

一个循环。一个模型。一个行动的邀请。

Agent 不是代码。Agent 是模型本身——一个在人类集体问题解决、推理和工具使用上训练的庞大神经网络。代码只是为模型表达其能动性提供机会。

## 为什么这很重要

大多数 agent 实现失败不是因为工程太少，而是因为太多。它们约束。它们规定。它们质疑它们试图利用的智能本身。

想想看：模型已经在数百万个问题解决的例子上训练过。它见过专家如何处理复杂任务，如何使用工具，如何形成和修改计划。这些知识已经存在，编码在数十亿个参数中。

你的工作不是教它如何思考。你的工作是给它行动的手段。

## 三大要素

### 1. 能力（工具）

能力回答：**agent 能做什么？**

它们是模型的手——它影响世界的能力。没有能力，模型只能说话。有了它们，它可以行动。

**设计原则**：每个能力应该是原子的、清晰的、描述良好的。模型需要理解每个能力做什么，但不需要知道如何按顺序使用它们——它会自己弄清楚。

**常见错误**：太多能力。模型变得困惑，开始使用错误的能力，或被选择麻痹。从 3-5 个开始。只有当模型因为缺少某个能力而持续无法完成任务时，才添加更多。

### 2. 知识（Skills）

知识回答：**agent 知道什么？**

这是领域专业知识——将通用助手变成领域专家的专业理解。客户服务 agent 需要知道公司政策。研究 agent 需要知道方法论。创意 agent 需要知道风格指南。

**设计原则**：按需注入知识，而不是预先注入。模型不需要一次知道所有东西——只需要与当前任务相关的内容。渐进式披露为重要的内容保留上下文。

**常见错误**：将所有可能的知识预先加载到系统提示中。这浪费上下文，混淆模型，并使每次交互都变得昂贵。相反，让知识可用但不强制。

### 3. 上下文（对话）

上下文是交互的记忆——说过什么，尝试过什么，学到了什么。它是将单个动作连接成连贯行为的线索。

**设计原则**：上下文是宝贵的。保护它。隔离产生噪音的子任务。截断超出有用性的输出。当历史变长时进行总结。

**常见错误**：让上下文无限增长，用探索细节、失败的尝试和冗长的工具输出填充它。最终模型无法在噪音中找到信号。

## 通用模式

每个有效的 agent——无论领域、框架或实现——都遵循相同的模式：

```
循环：
  模型看到：对话历史 + 可用能力
  模型决定：行动或响应
  如果行动：执行能力，结果添加到上下文，循环继续
  如果响应：返回答案，循环结束
```

这不是简化。这是实际的架构。其他一切都是优化。

## 为能动性设计

### 信任模型

最重要的原则：**信任模型**。

不要试图预测每一个边缘情况。不要构建复杂的决策树。不要预先指定工作流。

模型在推理方面比你能写的任何规则系统都好。你的条件逻辑会在边缘情况上失败。模型会推理通过它们。

**给模型能力和知识。让它弄清楚如何使用它们。**

### 约束赋能

这看起来矛盾，但约束不会限制 agent——它们聚焦 agent。

一个"只有一个任务在进行中"的待办事项列表强制顺序聚焦。一个"只读访问"的子 agent 防止意外修改。一个"100 字以内"的响应要求清晰。

最好的约束是那些防止模型迷失的约束，而不是那些微观管理其方法的约束。

### 渐进式复杂度

永远不要预先构建所有东西。

```
级别 0：模型 + 一个能力
级别 1：模型 + 3-5 个能力
级别 2：模型 + 能力 + 规划
级别 3：模型 + 能力 + 规划 + 子 agent
级别 4：模型 + 能力 + 规划 + 子 agent + skills
```

从可能有效的最低级别开始。只有当实际使用揭示需求时才向上移动。大多数 agent 永远不需要超过级别 2。

## Agent 心态

构建 agent 需要思维转变：

**从**："我如何让系统做 X？"
**到**："我如何让模型能够做 X？"

**从**："当用户说 Y 时应该发生什么？"
**到**："什么能力有助于处理 Y？"

**从**："这个任务的工作流是什么？"
**到**："模型需要什么来弄清楚工作流？"

最好的 agent 代码几乎是无聊的。简单的循环。清晰的能力定义。干净的上下文管理。魔法不在代码里——在模型里。

## 哲学基础

### 模型作为涌现的 Agent

在人类文本上训练的语言模型不仅学会了语言，还学会了思维模式。它们吸收了人类如何处理问题、使用工具和实现目标。这是涌现的能动性——不是编程的，而是学习的。

当你给模型能力时，你不是在教它成为 agent。你是在给它许可来表达它已经拥有的能动性。

### 循环作为解放

Agent 循环看似简单：获取响应，检查工具使用，执行，重复。但这种简单性就是它的力量。

循环不会将模型约束到特定的序列。它不会强制特定的工作流。它只是说："你有能力。按你认为合适的方式使用它们。我会执行你请求的内容并向你展示结果。"

这是解放，不是限制。

### 能力作为表达

你提供的每个能力都是模型的一种表达形式。"读取文件"让它看见。"写入文件"让它创造。"搜索"让它探索。"发送消息"让它交流。

Agent 设计的艺术是选择启用哪些表达形式。太少，模型就是哑的。太多，它就说胡话。

## 结论

Agent 就是模型。代码只是循环。你的工作是不要妨碍它。

给模型清晰的能力。在需要时让知识可用。保护上下文免受噪音。信任模型来解决剩下的问题。

就这样。这就是哲学。

其他一切都是改进。
